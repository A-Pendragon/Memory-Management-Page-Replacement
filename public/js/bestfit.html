<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

<script type="text/javascript">
	var operatingSystem = [

		{name: "Partition #1", partitionSize:100, internalFragmentation:0, jobSizeAllocated:0},	
		{name: "Partition #2", partitionSize:500, internalFragmentation:0, jobSizeAllocated:0},	
		{name: "Partition #3", partitionSize:200, internalFragmentation:0, jobSizeAllocated:0},
		{name: "Partition #4", partitionSize:300, internalFragmentation:0, jobSizeAllocated:0},
		{name: "Partition #5", partitionSize:600, internalFragmentation:0, jobSizeAllocated:0},
	];

	var jobs = [
		{name: "Job #1", jobSize:212},
		{name: "Job #2", jobSize:417},
		{name: "Job #3", jobSize:112},
		{name: "Job #4", jobSize:426},
	];

	var candidate = [];

	// finds the candidate
	// for (var i = 0; i < jobs.length; i++) {
	// 	for (var j = 0; j < operatingSystem.length; j++) {
	// 		if(jobs[i].jobSize <= operatingSystem[j].partitionSize){
	// 			candidate.push(operatingSystem[j])
	// 		}
			
	// 	}	
	// }
	// console.log(candidate);

	function findBestCandidate(candidate_1,candidate_2){
		if(candidate_1.partitionSize > candidate_2.partitionSize){
			candidate.splice(candidate.indexOf(candidate_1),1);
		}
		else{
			candidate.splice(candidate.indexOf(candidate_2),1);
		}
		return candidate;
	}


	
	for (var i = 0; i < jobs.length; i++) {				//finds the qualified partition for the job
		for (var j = 0; j < operatingSystem.length; j++) {
			if(jobs[i].jobSize <= operatingSystem[j].partitionSize){
				candidate.push(operatingSystem[j]);
			}
		
		}	

		for (var z = 0; z < candidate.length; z++) {		//finds the best fit for the job
			var bestCandidate = findBestCandidate(candidate[z],candidate[z+1]);
		}	

		// bestCandidate.jobSizeAllocated = jobs[i].jobSize;
		// bestCandidate.internalFragmentation = bestCandidate.partitionSize - jobs[i].jobSize;
	}
	



	





	// for (var i = 0; i < jobs.length; i++) {

	// 	for (var j = 0; j+1 < operatingSystem.length; j++) {
	// 		if (operatingSystem[j].jobSizeAllocated == 0) {	
	// 			if (operatingSystem[j].partitionSize >= jobs[i].jobSize) {
	// 				var candidate = operatingSystem[j];
	// 				if(operatingSystem[j+1].partitionSize> jobs[i].jobSize){
	// 					var candidate_2 = operatingSystem[j+1];
	// 					if (candidate.partitionSize > candidate_2) {
	// 						var bestCandidate = candidate_2;
	// 					}
	// 				}
	// 				else{
	// 					bestCandidate = candidate;
	// 				}
	// 				bestCandidate.jobSizeAllocated = jobs[i].jobSize;

	// 			}

	// 		} 
	// 	}
	// 	console.log(bestCandidate);
	// 	// bestCandidate.jobSizeAllocated = jobs[i].jobSize;
	// 	bestCandidate.internalFragmentation = bestCandidate.partitionSize - jobs[i].jobSize;
	// }

	// var sortedViaPartition = operatingSystem.sort(function(a,b){
	// 	return a.partitionSize - b.partitionSize;
	// });

	// for (var i = 0; i < jobs.length; i++) {

	// 	for (var j = 0; j < sortedViaPartition.length; j++) {
	// 		if (sortedViaPartition[j].jobSizeAllocated == 0 && jobs[i].state == false) {
	// 			if(sortedViaPartition[j].partitionSize >= jobs[i].jobSize){
	// 			sortedViaPartition.jobSizeAllocated = jobs[i].jobSize;
	// 			sortedViaPartition.internalFragmentation = sortedViaPartition.partitionSize - jobs[i].jobSize; 
	// 			jobs[i].state = true;
	// 			}	
	// 		}
	// 	}
	// }










</script>

</body>
</html>